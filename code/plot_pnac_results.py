#!/usr/bin/env python3
"""
PNAC Results Plotter
--------------------
Generates publication-quality figures from real PNAC experimental results.
Creates:
1. F1 decay curves for various noise rates
2. Beta-to-noise calibration curve

This script reads the summary.json files generated by pnac.py and
creates the figures for the manuscript.
"""

import json
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from pathlib import Path

# Configure matplotlib for publication-quality figures
rcParams['font.family'] = 'serif'
rcParams['font.size'] = 11
rcParams['axes.linewidth'] = 1.2
rcParams['xtick.major.width'] = 1.2
rcParams['ytick.major.width'] = 1.2
rcParams['xtick.direction'] = 'in'
rcParams['ytick.direction'] = 'in'
rcParams['xtick.top'] = True
rcParams['ytick.right'] = True
rcParams['lines.linewidth'] = 2

# Paths
SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent
RESULTS_DIR = SCRIPT_DIR / "pnac_results"
OUTPUT_DIR = PROJECT_ROOT / "figures"


def load_results():
    """
    Load all PNAC results from the results directory, aggregating by noise level.

    Returns:
        Dict mapping noise_rate -> list of result dictionaries (one per seed).
    """
    results_by_noise = {}

    if not RESULTS_DIR.exists():
        print(f"Results directory not found: {RESULTS_DIR}")
        print("Please run run_calibration.py first.")
        return results_by_noise

    # Find all summary files in noise_*/seed_* subdirectories
    for noise_dir in sorted(RESULTS_DIR.glob("noise_*")):
        noise_rate_str = noise_dir.name.replace("noise_", "")
        try:
            noise_rate = float(noise_rate_str)
        except ValueError:
            continue

        if noise_rate not in results_by_noise:
            results_by_noise[noise_rate] = []

        # Look for summary.json in seed subdirectories
        for seed_dir in sorted(noise_dir.glob("seed_*")):
            summary_files = list(seed_dir.glob("**/summary.json"))
            if summary_files:
                summary_file = sorted(summary_files)[-1]
                try:
                    with open(summary_file, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        results_by_noise[noise_rate].append(data)
                        print(f"Loaded: {summary_file.relative_to(RESULTS_DIR)}")
                except Exception as e:
                    print(f"Error loading {summary_file}: {e}")

    # Count total results
    total = sum(len(v) for v in results_by_noise.values())
    print(f"\nLoaded {total} result sets across {len(results_by_noise)} noise levels")
    return results_by_noise


def plot_decay_curves(results_by_noise):
    """
    Generate F1 decay curves for all noise rates with error bars.

    Parameters:
        results_by_noise: Dict mapping noise_rate -> list of result dicts

    Returns:
        Path to the saved figure
    """
    if not results_by_noise:
        print("No results to plot!")
        return None

    fig, ax = plt.subplots(figsize=(7, 5))

    # Sort noise rates
    noise_rates = sorted(results_by_noise.keys())

    # Color gradient from blue (clean) to red (noisy)
    colors = plt.cm.RdYlBu_r(np.linspace(0.15, 0.85, len(noise_rates)))

    all_f1 = []
    max_iter = 0

    for i, rho in enumerate(noise_rates):
        seed_results = results_by_noise[rho]
        if not seed_results:
            continue

        # Collect F1 scores from all seeds
        all_f1_arrays = [np.array(res.get('f1_scores', [])) for res in seed_results]

        # Find minimum length to align arrays
        min_len = min(len(arr) for arr in all_f1_arrays)
        if min_len == 0:
            continue

        # Stack and compute mean/std
        f1_matrix = np.array([arr[:min_len] for arr in all_f1_arrays])
        f1_mean = np.mean(f1_matrix, axis=0)
        f1_std = np.std(f1_matrix, axis=0)

        iterations = np.arange(min_len)
        max_iter = max(max_iter, min_len)
        all_f1.extend(f1_mean.tolist())

        label = f'$\\rho = {rho:.1f}$'

        # Plot mean line with error band
        ax.plot(iterations, f1_mean, 'o-', color=colors[i],
                linewidth=2, markersize=7, markeredgecolor='white',
                markeredgewidth=0.8, label=label)

        # Add error band (shaded region for ±1 std)
        ax.fill_between(iterations, f1_mean - f1_std, f1_mean + f1_std,
                        color=colors[i], alpha=0.2)

    # Formatting
    ax.set_xlabel('PNAC Iteration ($t$)', fontsize=12)
    ax.set_ylabel('Validation Macro-F1', fontsize=12)

    # Set axis limits based on data
    if all_f1:
        y_min = min(all_f1) - 0.08
        y_max = max(all_f1) + 0.03
        ax.set_ylim(max(0, y_min), min(1, y_max))

    ax.set_xlim(-0.2, max_iter - 0.8)
    ax.set_xticks(range(max_iter))

    ax.legend(loc='lower left', frameon=True, fancybox=False,
              edgecolor='black', fontsize=10, ncol=2, columnspacing=1)
    ax.grid(True, linestyle='--', alpha=0.3, linewidth=0.8)

    # Add annotation
    ax.annotate('Higher noise $\\rightarrow$ faster decay',
                xy=(0.55, 0.92), xycoords='axes fraction',
                fontsize=10, style='italic', color='gray')

    plt.tight_layout()

    # Save figure
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    output_path = OUTPUT_DIR / "decay_curves.pdf"
    plt.savefig(output_path, format='pdf', dpi=300, bbox_inches='tight')
    plt.close()

    print(f"Saved: {output_path}")
    return output_path


def plot_beta_calibration(results_by_noise):
    """
    Generate calibration curve showing beta vs. noise rate with error bars.

    Parameters:
        results_by_noise: Dict mapping noise_rate -> list of result dicts

    Returns:
        Path to the saved figure
    """
    if not results_by_noise:
        print("No results to plot!")
        return None

    # Extract noise rates and beta values (mean ± std across seeds)
    noise_rates = []
    beta_means = []
    beta_stds = []

    for rho in sorted(results_by_noise.keys()):
        seed_results = results_by_noise[rho]
        betas_for_noise = [res.get('decay_beta') for res in seed_results
                          if res.get('decay_beta') is not None]

        if betas_for_noise:
            noise_rates.append(rho)
            beta_means.append(np.mean(betas_for_noise))
            beta_stds.append(np.std(betas_for_noise))

    if len(noise_rates) < 2:
        print("Not enough data points for calibration curve")
        return None

    noise_rates = np.array(noise_rates)
    beta_means = np.array(beta_means)
    beta_stds = np.array(beta_stds)

    fig, ax = plt.subplots(figsize=(6, 5))

    # Plot data points with error bars
    ax.errorbar(noise_rates, beta_means, yerr=beta_stds, fmt='s', color='#2E5EAA',
                markersize=10, markeredgecolor='white', markeredgewidth=1.5,
                capsize=5, capthick=2, elinewidth=2,
                label='Measured $\\beta$ (mean $\\pm$ std)')

    # Fit and plot regression line using mean values
    coeffs = np.polyfit(noise_rates, beta_means, 1)
    poly = np.poly1d(coeffs)
    x_fit = np.linspace(-0.02, max(noise_rates) + 0.02, 100)
    ax.plot(x_fit, poly(x_fit), '--', color='#CC4444', linewidth=2, alpha=0.8,
            label=f'Fit: $\\beta = {coeffs[0]:.2f}\\rho + {coeffs[1]:.2f}$')

    # Calculate R^2
    ss_res = np.sum((beta_means - poly(noise_rates))**2)
    ss_tot = np.sum((beta_means - np.mean(beta_means))**2)
    if ss_tot > 0:
        r_squared = 1 - (ss_res / ss_tot)
    else:
        r_squared = 0

    # Formatting
    ax.set_xlabel('Injected Noise Rate ($\\rho$)', fontsize=12)
    ax.set_ylabel('Decay Rate ($\\beta$)', fontsize=12)
    ax.set_xlim(-0.03, max(noise_rates) + 0.03)

    # Set y-axis limits
    y_min = min(0, min(beta_means - beta_stds) - 0.05)
    y_max = max(beta_means + beta_stds) + 0.1
    ax.set_ylim(y_min, y_max)

    ax.set_xticks(noise_rates)
    ax.legend(loc='upper left', frameon=True, fancybox=False,
              edgecolor='black', fontsize=10)
    ax.grid(True, linestyle='--', alpha=0.3, linewidth=0.8)

    # Add R^2 annotation
    ax.annotate(f'$R^2 = {r_squared:.3f}$',
                xy=(0.65, 0.15), xycoords='axes fraction',
                fontsize=11, bbox=dict(boxstyle='round,pad=0.3',
                                       facecolor='white', edgecolor='gray', alpha=0.9))

    plt.tight_layout()

    # Save figure
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    output_path = OUTPUT_DIR / "beta_vs_noise.pdf"
    plt.savefig(output_path, format='pdf', dpi=300, bbox_inches='tight')
    plt.close()

    print(f"Saved: {output_path}")
    return output_path


def print_summary_table(results_by_noise):
    """Print a summary table of the results with mean ± std across seeds."""
    if not results_by_noise:
        return

    print("\n" + "="*80)
    print("PNAC CALIBRATION SUMMARY (mean ± std across seeds)")
    print("="*80)
    print(f"{'Noise Rate':<12} {'Seeds':<8} {'Initial F1':<16} {'Final F1':<16} {'Beta':<16}")
    print("-"*80)

    for rho in sorted(results_by_noise.keys()):
        seed_results = results_by_noise[rho]
        n_seeds = len(seed_results)

        # Collect metrics from all seeds
        f1_inits = []
        f1_finals = []
        betas = []

        for res in seed_results:
            f1_scores = res.get('f1_scores', [])
            beta = res.get('decay_beta')

            if f1_scores:
                f1_inits.append(f1_scores[0])
                f1_finals.append(f1_scores[-1])
            if beta is not None:
                betas.append(beta)

        # Format as mean ± std
        if f1_inits:
            f1_init_str = f"{np.mean(f1_inits):.3f} ± {np.std(f1_inits):.3f}"
        else:
            f1_init_str = "N/A"

        if f1_finals:
            f1_final_str = f"{np.mean(f1_finals):.3f} ± {np.std(f1_finals):.3f}"
        else:
            f1_final_str = "N/A"

        if betas:
            beta_str = f"{np.mean(betas):.4f} ± {np.std(betas):.4f}"
        else:
            beta_str = "N/A"

        print(f"{rho:<12.1f} {n_seeds:<8} {f1_init_str:<16} {f1_final_str:<16} {beta_str:<16}")

    print("="*80)


def main():
    """Generate all PNAC result figures."""
    print("PNAC Results Plotter")
    print("="*60)
    print(f"Results directory: {RESULTS_DIR}")
    print(f"Output directory: {OUTPUT_DIR}")
    print()

    # Load results (now grouped by noise level)
    results_by_noise = load_results()

    if not results_by_noise:
        print("\nNo results found! Please run run_calibration.py first.")
        return

    # Print summary
    print_summary_table(results_by_noise)

    # Generate figures
    print("\nGenerating figures...")

    path1 = plot_decay_curves(results_by_noise)
    path2 = plot_beta_calibration(results_by_noise)

    print()
    print("="*60)
    print("DONE! Generated figures:")
    if path1:
        print(f"  1. {path1}")
    if path2:
        print(f"  2. {path2}")
    print()
    print("These figures can be included in the manuscript at:")
    print("  - Figure decay_curves.pdf -> \\ref{fig:decay_curves}")
    print("  - Figure beta_vs_noise.pdf -> \\ref{fig:beta_vs_noise}")


if __name__ == '__main__':
    main()
